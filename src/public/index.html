<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <title>Ratatoskr</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
    <style>
        html,
        body {
            width: 100%;
            height: 99%;
            overflow: hidden;
        }
        .editor {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        .container {
            display: flex;
            /* Misc */
            border: 1px solid #cbd5e0;
            height: 98%;
            width: 99.9%;
        }
        .resizer[data-direction=horizontal] {
            background-color: #cbd5e0;
            cursor: ew-resize;
            height: 100%;
            width: 3px;
        }
        .resizer[data-direction=vertical] {
            background-color: #cbd5e0;
            cursor: ns-resize;
            height: 3px;
            width: 100%;
        }
        .container__left {
            /* Initially, the left takes 1/4 width */
            width: 25%;
            padding: 1px;
            /* Misc */
            align-items: center;
            display: flex;
            justify-content: center;
            margin: 1px;
        }
        .container__right {
            flex: 1;
            /* Misc */
            align-items: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .container__top {
            /* Initial height */
            flex: 1;
            min-height: 150px;
            margin: 1px;
            /* Misc */
            align-items: center;
            display: flex;
            justify-content: center;
            width: 100%;
        }
        .container__bottom {
            /* Take the remaining height */
            height: 12rem;
            /* Misc */
            align-items: center;
            display: flex;
            justify-content: center;
            margin: 1px;
            width: 100%;
            height: 50%;
        }
        .container__control {
            /* Take the remaining height */
            height: 1.3rem;
            /* Misc */
            align-items: right;
            display: flex;
            justify-content: right;
            margin: 1px;
            width: 100%;
        }
        .fill {
            border: 0;
            height: 100%;
            width: 100%;
        }
    </style>




</head>

<body>
    <div class="container">
        <div id="left" class="container__left">
            <div class="fill editor"></div>
        </div>
        <div class="resizer" data-direction="horizontal"></div>
        <div class="container__right">
            <div id="top" class="container__top">
                <div class="fill editor">
                </div>
            </div>
            <div class="resizer" data-direction="vertical"></div>
            <div id="bottom" class="container__bottom">
                <div class="fill editor"></div>
            </div>
            <div class="container__control"><button id="btn">hello</button></div>
        </div>
    </div>

    <script src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/ace.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/axios/0.27.2/axios.min.js'></script>
    <script id="rendered-js" type="module">

        function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } import OpenAI from "https://cdn.skypack.dev/openai-api";
        const OPENAI_API_KEY = "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";
        const openai = new OpenAI(OPENAI_API_KEY);
        // the following function accepts mp3 binary data (the response from the synthesizeSpeech method from the @google-cloud/text-to-speech package) and plays tbe audio.
        // parameter: binaryData - the binary mp3 data to play
        // parameter: settings - playback control settings
        // returns: Promise that resolves once the audio is finished playing
        function playAudio(audioData) {
            return new Promise(function (resolve, reject) {
                var audio = new Audio();
                audio.addEventListener('error', function (err) {
                    reject(err);
                }, false);
                audio.addEventListener('ended', function () {
                    resolve();
                }, false);
                audio.src = 'data:audio/mp3;base64,' + audioData;
                audio.play();
            });
        }
        function generateAudio(
            phrase,
            voiceSettings = {
                name: "en-US-Wavenet-C",
                languageCode: "en-US"
            },
            playbackSettings = {
                onStart: () => { },
                onEnd: () => { },
                onError: () => { }
            }) {
            return new Promise((resolve, reject) => {
                // create the request body
                const requestBody = {
                    input: { ssml: phrase },
                    voice: {
                        name: "en-US-Wavenet-C",
                        languageCode: "en-US"
                    },
                    audioConfig: { audioEncoding: "mp3" }
                };
                axios.
                    post(
                        "https://texttospeech.googleapis.com/v1/text:synthesize?key=AIzaSyDnUfbzrUfwwJGCUGsy3L7K3mdcsM6b8rU",
                        requestBody).
                    then(function (response) {
                        // check the response status
                        if (response.status !== 200) {
                            reject(new Error(`Request failed with status code ${response.status}`));
                        }
                        // get the response body
                        resolve(response.data.audioContent);
                    }).
                    catch(function (error) { reject(error); });
            });
        }
        async function speakPhrase(phrase, voiceSettings, playbackSettings) {
            const audioData = await generateAudio(
                phrase,
                voiceSettings,
                playbackSettings);
            playAudio(
                audioData,
                {
                    volume: 1,
                    rate: 1,
                    pitch: 1
                },
                {
                    onStart: () => { },
                    onEnd: () => { },
                    onError: () => { }
                });
        }
        const queryAI = async question => {
            const gptResponse = await openai.complete({
                engine: "text-davinci-002",
                prompt: question,
                maxTokens: 256,
                temperature: 0.7,
                topP: 1,
                presencePenalty: 0,
                frequencyPenalty: 0,
                bestOf: 1,
                n: 1,
                stream: false,
                stop: ["<|-->"]
            });
            return gptResponse.data.choices[0].text;
        };

        document.addEventListener('DOMContentLoaded', function () {

            const resizable = function (resizer) {
                const direction = resizer.getAttribute('data-direction') || 'horizontal';
                const prevSibling = resizer.previousElementSibling;
                const nextSibling = resizer.nextElementSibling;
                // The current position of mouse
                let x = 0;
                let y = 0;
                let prevSiblingHeight = 0;
                let prevSiblingWidth = 0;
                // Handle the mousedown event
                // that's triggered when user drags the resizer
                const mouseDownHandler = function (e) {
                    // Get the current mouse position
                    x = e.clientX;
                    y = e.clientY;
                    const rect = prevSibling.getBoundingClientRect();
                    prevSiblingHeight = rect.height;
                    prevSiblingWidth = rect.width;
                    // Attach the listeners to `document`
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                };
                const mouseMoveHandler = function (e) {
                    // How far the mouse has been moved
                    const dx = e.clientX - x;
                    const dy = e.clientY - y;
                    switch (direction) {
                        case 'vertical':
                            const h =
                                (prevSiblingHeight + dy) * 100 /
                                resizer.parentNode.getBoundingClientRect().height;
                            prevSibling.style.height = `${h}%`;
                            break;
                        case 'horizontal':
                        default:
                            const w =
                                (prevSiblingWidth + dx) * 100 / resizer.parentNode.getBoundingClientRect().width;
                            prevSibling.style.width = `${w}%`;
                            break;
                    }
                    const cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';
                    resizer.style.cursor = cursor;
                    document.body.style.cursor = cursor;
                    prevSibling.style.userSelect = 'none';
                    prevSibling.style.pointerEvents = 'none';
                    nextSibling.style.userSelect = 'none';
                    nextSibling.style.pointerEvents = 'none';
                };
                const mouseUpHandler = function () {
                    resizer.style.removeProperty('cursor');
                    document.body.style.removeProperty('cursor');
                    document.getElementById('btn').addEventListener('click', function () {
                        listen();
                    });
                    prevSibling.style.removeProperty('user-select');
                    prevSibling.style.removeProperty('pointer-events');
                    nextSibling.style.removeProperty('user-select');
                    nextSibling.style.removeProperty('pointer-events');
                    // Remove the handlers of `mousemove` and `mouseup`
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                };
                // Attach the handler
                resizer.addEventListener('mousedown', mouseDownHandler);
            };

            // Query all resizers
            document.querySelectorAll('.resizer').forEach(function (ele) {
                resizable(ele);
            });

            var editor1 = ace.edit("top");
            editor1.setTheme("ace/theme/monokai");
            editor1.session.setMode("ace/mode/javascript");
            var editor2 = ace.edit("bottom");
            editor2.setTheme("ace/theme/monokai");
            editor2.session.setMode("ace/mode/javascript");
            var editor3 = ace.edit("left");
            editor3.setTheme("ace/theme/monokai");
            editor3.session.setMode("ace/mode/javascript");
            var editors = {
                editor1,
                editor2,
                editor3
            };

            var onCommand = (editor, target) => {
                var query = editor.getValue();
                query = conversation.converse(query);
                var index = getEditorIndex(editor);
                if (target === 'current') {
                    target = index;
                }
                var editorName = `editor${target}`;
                queryAI(query).then(response => {
                    response = conversation.processAIResponse(response);
                    editors['editor2'].setValue('');
                    editors[editorName].setValue(response);
                });
            };

            var getEditorIndex = e => {
                if (e === editor1) return 1;
                if (e === editor2) return 2;
                if (e === editor3) return 3;
            };

            Object.values(editors).forEach(editor => {
                editor.commands.addCommand({
                    name: "query current",
                    bindKey: { win: "Ctrl-Enter", mac: "Command-Enter" },
                    exec: editor => onCommand(editor, '1')
                });

                editor.commands.addCommand({
                    name: "query 1",
                    bindKey: { win: "Ctrl-1", mac: "Command-1" },
                    exec: editor => onCommand(editor, '1') });

                editor.commands.addCommand({
                    name: "query 2",
                    bindKey: { win: "Ctrl-2", mac: "Command-2" },
                    exec: editor => onCommand(editor, '2') });

                editor.commands.addCommand({
                    name: "query 3",
                    bindKey: { win: "Ctrl-3", mac: "Command-3" },
                    exec: editor => onCommand(editor, '3') });

                editor.setValue("");
            });
            editor1.setValue('');
            editor2.setValue('');
            window.editors = editors;
        });

        const speechRecognition = window.speechRecognition || window.webkitSpeechRecognition;
        function listen() {
            var recognition = new speechRecognition();
            var hailed = false,
                hailWord = "Eva";
            var resetTimer;
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.onstart = () => {
                console.log('listening');
            };
            recognition.onend = () => {
                console.log('stopped listening');
                listen();
            };
            recognition.onerror = err => {
                console.log('listening error', err);
            };
            recognition.onresult = async function (event) {
                var interim_transcript = "";
                var interim_save = undefined;
                for (var i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        if (resetTimer) {
                            clearTimeout(resetTimer);
                            resetTimer = null;
                        }
                        resetTimer = setTimeout(() => {
                            if (!resetTimer) return;
                            window.editors['editor3'].setValue('');
                            resetTimer = undefined;
                            hailed = false;
                            console.log('reset hailed');
                        }, 5000);
                        if (!hailed) { console.log('mot hailed'); continue; }
                        let text = event.results[i][0].transcript;
                        const splitWords = text.split(" ");
                        const hailIndex = splitWords.findIndex((e, i) => hailWord === e);
                        let qp = text;
                        if (hailIndex > -1) {
                            const queryPhrase = splitWords.slice(
                                hailIndex + 1,
                                splitWords.length);

                            qp = queryPhrase.join(" ");
                            window.editors['editor2'].setValue(interim_save + qp);
                            interim_save = undefined;
                            const aiq = conversation.converse(qp);
                            window.editors['editor3'].setValue(aiq);
                            speakPhrase(aiq);
                            let response = await queryAI(aiq);
                            if (resetTimer) {
                                clearTimeout(resetTimer);
                                resetTimer = null;
                            }
                            // remove leading and trailing newlines and spaces from response
                            response = response.replace(/^\s+|\s+$/g, "");
                            response = conversation.processAIResponse(response);
                            response = response.replace(/^EVA:|\s+$/g, "");
                            window.editors['editor1'].setValue(response);
                            window.editors['editor2'].setValue('');
                            speakPhrase(response);
                        }
                    } else {
                        interim_transcript += event.results[i][0].transcript;
                        const splitWords = interim_transcript.split(" ");
                        window.editors['editor2'].setValue(interim_transcript);
                        if (splitWords.includes("Eva")) {
                            hailed = true;
                            console.log('hailed');
                        }
                        if (splitWords.includes("deface")) {
                            window.editors['editor2'].setValue('');
                        }
                    }
                }
            };
            recognition.start();
        }
        listen();
    </script>


</body>

</html>